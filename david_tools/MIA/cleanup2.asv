function cleanup2

%written by DP - last update 11/04/07
%screens events generated by MIA according to various criteria (see code)
%and generates a .trc file with the events passing the screen
%generates also a summary excel file where all the parameters and results
%are written

%This function works with the two types of trc files: with or without 
%the '0' lines. It will write the '0' lines if they were present.

[f,p] = uigetfile('*.txt;*.trc','File with matrix of events');
if ~f,return,end
events = dlmread([p,f],'\t');
cellNum = f(1:4); %the number of the cell analysed
[stk,stkd] = uigetfile('*.stk','Choose a Stack');
if ~stk,return,end
[stkMIA,stkdMIA] = ...
    uigetfile('*.stk','Stack of clusters (TfR7, MIA objects)');
movi = stkread(stk,stkd);
moviLength = size(movi,3);
output = zeros(size(events));

rCircle = 3;
rAnn = 6; %radius of the Annulus
Edge = 13;
sigNoise = 2;
slopeMax = 0.1;
minFrame = 20; % Number of frames before the event
%It has to be bigger than 5 
%(the number of frames used to estimate local background)
maxFrame = 20;
defaults = [rCircle,rAnn,Edge,sigNoise,slopeMax,minFrame,maxFrame];
prompt = {'Circle radius','Annulus outer radius',...
    'Minimal distance from the edge of the image',...
    'Signal/Noise ratio',...
    'Maximum slope for fluorescence increase',...
    'Minimal number of frames before event (>5)',...
    'Minimal number of frames after start of event'};
[rCircle,rAnn,Edge,sigNoise,slopeMax,minFrame,maxFrame] = ...
numinputdlg(prompt,'Parameters for removing non qualified events',1,defaults);
pause(1)
params = [rCircle,rAnn,Edge,sigNoise,slopeMax,minFrame,maxFrame];
[x,y] = meshgrid(1:2*rAnn+1);
k = 1; %token for the output matrix
r = 1; %token for the reject matrix
a = 1; %token for the accept matrix 
if events(1,1) == 0
    firstEvent = round(events(2,1));
else
    firstEvent = round(events(1,1));
end
lastEvent = round(events(end,1));
reject = zeros(lastEvent,12);
accept = zeros(lastEvent,6);
for i=firstEvent:lastEvent
    eventTrack = (events(:,1)==i);
    [u,start] = max(eventTrack);
    if u
    if (events(start,2) > minFrame)
    if (events(start,2) < moviLength-maxFrame)
        if (Edge < events(start,3))...
            && (events(start,3) < (size(movi,2)-Edge))...
            && (Edge < events(start,4))...
            && (events(start,4) < (size(movi,1)-Edge))
%Conditions: The object appears after minFrame frames 
%and is more than Edge pixels from the edge of the image
        if ~(events(1,1)==0)|((events(1,1)==0) & (events(start-1,3) == 0))
%Condition: if it is coded (0 lines), the object is not merge/split from
%parent objects
        frame = round(events(start,2));
        length = sum(eventTrack);
        if length >= 3
%A condition that is normally always fullfilled
%since MIA uses a minimum of 3 frames to define an event
%but in fact there can be events with less than 3 if they lead to or come from
%a merge/split
%Warning: these events will disappear from the excel summary file
%Calculates the slope

            xy1 = floor(events(start,3:4))+1;
            dxy1 = events(start,3:4)-xy1+1;
            xy3 = floor(events(start+2,3:4))+1;
            dxy3 = events(start+2,3:4)-xy3+1;
            distance1 = sqrt((x-rAnn-dxy1(1)-1).^2 +...
                (y-rAnn-dxy1(2)-1).^2);
            distance3 = sqrt((x-rAnn-dxy3(1)-1).^2 +...
                (y-rAnn-dxy3(2)-1).^2);
            circle1 = distance1<rCircle;
            annulus1 = (distance1>=rCircle)&(distance1<rAnn);
            circle3 = distance3<rCircle;
            annulus3 = (distance3>=rCircle)&(distance3<rAnn);
im1 = ...
  double(movi(xy1(2)-rAnn:xy1(2)+rAnn,xy1(1)-rAnn:xy1(1)+rAnn,frame));
im3 = ...
  double(movi(xy3(2)-rAnn:xy3(2)+rAnn,xy3(1)-rAnn:xy3(1)+rAnn,frame+2));
            av1 = sum(sum(im1.*circle1))/sum(sum(circle1)) -...
                sum(sum(im1.*annulus1))/sum(sum(annulus1));
            av3 = sum(sum(im3.*circle3))/sum(sum(circle3)) -...
                sum(sum(im3.*annulus3))/sum(sum(annulus3));
            slope = 0.5*(av3/av1-1);
%Calculates the background over 5 frames preceding the event
imbefore = ...
  double(movi(xy1(2)-rAnn:xy1(2)+rAnn,xy1(1)-rAnn:xy1(1)+rAnn,frame-5:frame-1));
            circle0 = circle1(:,:,ones(1,5));
            annulus0 = annulus1(:,:,ones(1,5));
            avbefore = sum(sum(imbefore.*circle0))/sum(sum(circle1))-...
              sum(sum(imbefore.*annulus0))/sum(sum(annulus1));
            average = sum(avbefore)./5;
            stdev = sqrt(sum((average-avbefore).^2))./2;
            if stdev ~= 0
                SN = (av1-average)/stdev;
            else
                SN = 1000; %should be infinity
            end
%Condition: the spot does not get brighter after appearance
%(as an approaching object would do)
            if slope < slopeMax
 %The last condition: fluo of object above background
                if SN > sigNoise
                   if events(1,1) == 0
                       start = start-1;length = length+1;
                   end
                   output(k:k+length-1,:) = events(start:start+length-1,:);
                    k = k+length;
                    accept(a,1) = i;
                    %accept(a,2) = a;
                    accept(a,2:4) = events(start+1,2:4);
                    accept(a,5) = slope;
                    accept(a,6) = SN;
                    a = a+1;
                else reject(r,1:4) = events(start,1:4); %rejection: S/N is too low
                    reject(r,5) = slope;
                    reject(r,6) = SN;
                    reject(r,11) = 1;
                    r = r+1;
                end
            else reject(r,1:4) = events(start,1:4); %rejection: slope is too high
                reject(r,5) = slope;
                reject(r,6) = SN;
                reject(r,10) = 1;
                r = r+1;
            end
            %some 'events' are rejected at this stage because they are too
            %short; doesn't count as a true rejection
        end
        else reject(r,1:6) = events(start,:); %rejection: event is a merge/split
            reject(r,12) = 1;
            r = r+1;
        end
        else reject(r,1:6) = events(start,:); %rejection: event is close to an edge
            reject(r,9) = 1;
            r = r+1;
        end
    else reject(r,1:6) = events(start,:); %rejection: event is too late
        reject(r,8) = 1;
        r = r+1;
    end
    else reject(r,1:6) = events(start,:);
        reject(r,7) = 1; %rejection: event is too early
        r = r+1;
    end
    end
end

output = output(1:k-1,:);
reject = reject(1:r-1,:);
sumReject = sum(reject);
counts = [(r+a-2);sumReject(7:12)';(a-1)];
accept = accept(1:a-1,:);

cellHigh = max(size(accept,1),size(reject,1))+15;
tableSum = cell(cellHigh,19); %the cell array that will contain the xl sheet
tableSum(1:3,1) = {'exp type:';'analysis:';'date:'};
tableSum{3,2} = date;
tableSum(5:11,1) = {'rCircle';'rAnnulus';'Edge';'S/N';'(+)slope';'fr_bef';'fr_aft'};
tableSum(5:11,2) = num2cell(params');
tableSum(5:8,4) = {'total events:';'failed frbef:';'failed fraft:';'failed edges:'};
tableSum(9:12,4) = {'failed slope:';'failed S/N:';'failed merge:';'passed:'};
tableSum(5:12,5) = num2cell(counts);
tableSum{14,1} = 'passed events';
tableSum{14,8} = 'failed events';
tableSum(15,1:6) = {'trk id','fr','x','y','slope','S/N'};
tableSum(15,8:13) = {'trk id','fr','x','y','slope','S/N'};
tableSum(15,14:19) = {'frbef','fraft','edges','(+)slope','S/N','merge'};
tableSum(16:15+size(accept,1),1:6) = num2cell(accept);
tableSum(16:15+size(reject,1),8:19) = num2cell(reject);

[fle,p] = uiputfile([f(1:end-4),'_cln.trc']...
      ,'Where to put the cleaned up event file');
  
if ischar(fle)&ischar(p)
   dlmwrite([p,fle],output,'\t')
end

[fexcel,p] = uiputfile([cellNum,'_data.xls'],...
    'Where to put the excel data file');

if ischar(fexcel)&&ischar(p)
    warning off MATLAB:xlswrite:AddSheet
    sheet = [cellNum,' summary'];
    xlswrite([p,fexcel],tableSum,sheet)
end
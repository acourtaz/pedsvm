function cleanupDiff(varargin)

%Written by DP - last update 29/07/2014
%cleanupDiff(events,evMovie,clusterMovie)
%Parameters : events, TfR5 stk, TfR7 MIA stk, coeff
%Screens events generated by MIA on a diff movie (generated by diffMovie2)
%and generates a .trc file with the events passing the screen
%generates also a summary excel file where all the parameters and results
%are written
%Last update: rejects events if out of frame in red channel

if isempty(varargin)
    [f,p] = uigetfile('*.txt;*.trc','File with matrix of events (e.g. MIA.trc file');
    if ~f,return,end
    [stk,stkd] = uigetfile('*.stk','Stack of events (TfR5)/NOT the diffMovie!');
    if ~stk,return,end
    [stkMIA,stkdMIA] = ...
        uigetfile('*.stk','Stack of clusters (TfR7, MIA OBJECTS!)');
    if ~stkMIA
        warndlg('no screen for pre-existing cluster will be performed')
        clusters = [];
    else
        clusters = stkread(stkMIA,stkdMIA);
    end
    [coFile,coDir] = uigetfile('*.txt',...
        'File with alignment coefficients (if red quantification planned)');
    if ~coFile
        coeff = [];
    else coeff = dlmread([coDir,coFile],'\t');
    end
else
    p = [cd,'\'];
    f = varargin{1};
    stkd = p;
    stk = varargin{2};    
end
if size(varargin,2) == 2
    clusters = [];
    coeff = [];
elseif size(varargin,2) == 3
    stkdMIA = p;
    stkMIA = varargin{3};
    clusters = stkread(stkMIA,stkdMIA);
    coeff = [];
elseif size(varargin,2) == 4
    stkdMIA = p;
    stkMIA = varargin{3};
    clusters = stkread(stkMIA,stkdMIA);
    coDir = p;
    coFile = varargin{4};
    coeff = dlmread([coDir,coFile],'\t');
end

events = dlmread([p,f],'\t');
fk = strfind(f,'_');
cellNum = f(1:fk(1)-1); %the number of the cell analysed
sTRC = ~isempty(strfind(f,'.trc')); %0 for annotate.txt files, 1 for trc files

movi = stkread(stk,stkd);
moviLength = size(movi,3);
output = zeros(size(events));

%%Parameters
lowpercent = 0.2; %lower percentile of the pixel values used for background
highpercent = 0.8; %new from cleanup6rCircle = 3; %Radius of the circle for fluorescence quantification, in pixels
fBack = 5; %Number of frames for background calculation >2

rCircle = 2; %Radius of the circle for fluorescence quantification, in pixels
rAnn = 5; %radius of the Annulus
Edge = 7; %Minimal distance from the edge of the image
sigNoise = 5; %Signal/Noise ratio estimated on TfR5 movie
slopeMax = 1; %Maximum slope for fluorescence increase
thClst = 0.2; %Threshold for pre-existing cluster (0<T<=1) taken on TfR7 MIA movie
minFrame = 5; % Minimal number of frames before the event
%It has to be bigger than 5 
%(the number of frames used to estimate local background)
maxFrame = 5; %Minimal number of frames after start of event
maxMvt = 5; %Maximal number of pixels an object can move between two frames

%parameters not accessible by prompt
minTrack = 3; %Minimal number of frames to track an object
maxFTrack = 20; %Maximal number of frames an object will be tracked
pixThresh = 3; %Minimal number of pixels to form an object
corrFactor = 2.5; %Correction factor for segmentation, to get enough pixels above threshold
%
defaults = [rCircle,rAnn,Edge,sigNoise,slopeMax,thClst,minFrame,maxFrame,maxMvt];
prompt = {'Circle radius','Annulus outer radius',...
    'Minimal distance from the edge of the image',...
    'Signal/Noise ratio',...
    'Maximum slope for fluorescence increase',...
    'Threshold for pre-existing cluster (0<T<=1)',...
    'Minimal number of frames before event (>5)',...
    'Minimal number of frames after start of event',...
    'Maximal mvt between frames for tracking'};
[rCircle,rAnn,Edge,sigNoise,slopeMax,thClst,minFrame,maxFrame,maxMvt] = ...
numinputdlg(prompt,'Parameters for removing non qualified events',1,defaults);
pause(1)
params = [rCircle,rAnn,Edge,sigNoise,slopeMax,thClst,minFrame,maxFrame,maxMvt];
miniPix = (2*rAnn+1)^2;
[x,y] = meshgrid(1:2*rAnn+1);

%%Reordering events matrix and removing early/late events
events = sortrows(events,2);
isEarly = events(:,2) <= minFrame;
nEarly = sum(isEarly);
isLate = events(:,2) > moviLength - maxFrame;
nLate = sum(isLate);
events = events(nEarly+1:end-nLate,:);
events(:,1) = 1:size(events,1);

r = 0; %token for the reject matrix
a = 0; %token for the accept matrix 

reject = zeros(size(events,1),13);
accept = zeros(size(events,1),9);
nEvents = []; % For new trc file with tracked objects


%%Tests if candidate event is too close to edge, and
%if SN or cluster overlap too small
for i = 1:size(events,1)
    edge_xs = events(i,3) < Edge;
    edge_xl = events(i,3) > (size(movi,2)-Edge);
    edge_ys = events(i,4) < Edge;
    edge_yl = events(i,4) > (size(movi,1)-Edge);
    edge_xy = edge_xs|edge_xl|edge_ys|edge_yl;
    j=0; % local frame number 0 = start
    slope = 0;
    if ~edge_xy
        %Condition: Trajectory of event is more than Edge pixels from the edge of the image
        
        %Calculates fluo values for event image and 5 frames before to
        %calculate SN, to test the condition SN > sigNoise
        frame = round(events(i,2));
        xy = floor(events(i,3:4))+sTRC;
        dxy = events(i,3:4)-xy+sTRC;
        distance = sqrt((x-rAnn-dxy(1)-1).^2 + (y-rAnn-dxy(2)-1).^2);
        circle = distance<rCircle;
        annulus = (distance>=rCircle)&(distance<rAnn);
        nPix = squeeze(round(sum(sum(annulus))))';
        nLoPix = round(nPix*lowpercent);
        nHiPix = round(nPix*highpercent);            
        %Extension of circle and annulus for the fBack+1 frames
        circle = circle(:,:,ones(1,fBack+1));
        annulus = annulus(:,:,ones(1,fBack+1));
        
        im =  double(movi(xy(2)-rAnn:xy(2)+rAnn,xy(1)-rAnn:xy(1)+rAnn,frame-fBack:frame));
        back0 = im.*annulus;
        sortback0 = sort(reshape(back0,miniPix,fBack+1));
        background0 = ...
sum(sortback0(miniPix-nPix+nLoPix+1:miniPix-nPix+nHiPix,:))./(nHiPix-nLoPix);
        vals = sum(sum(im.*circle))/sum(sum(circle(:,:,1)));
        fluo = squeeze(vals)' - background0;
        fluoBef = sum(fluo(1:fBack))./fBack;
        stdev = sqrt(sum((fluo(1:fBack)-fluoBef).^2))./2;
        if stdev ~= 0
            SN = (fluo(fBack+1) - fluoBef)/stdev;
        else
            SN = 1000; %i.e. infinity
        end
%Calculates the fraction of pixels occupied by a pre-existing cluster in
%the circle for the fBack frames before AND the event frame
%Slightly different from other cleanup programs, where pre-existing cluster
%was tested for the fBack frames before, but not the event frame
        if ~isempty(clusters)
            clst = ...
        clusters(xy(2)-rAnn:xy(2)+rAnn,xy(1)-rAnn:xy(1)+rAnn,frame-fBack:frame)>0;
            coClst = sum(circle(:)&clst(:))/sum(circle(:));
        else
            coClst = 1;
        end
        if SN > sigNoise
            if coClst > thClst
%Performs subtracted image segmentation for tracking for up to X frames (?)
isObj = 1; %index for the presence of a segmented object
%j = 0; %local frame number (0 = start)
nEv = []; %new lines of trc file corresponding to tracked event
while isObj && j <= maxFTrack && frame+j < size(movi,3) && ~edge_xy
%Calculates new background on current object coordinates xy & dxy
    miniM = ... %new minimovie with fBack frames for background and current frame
double(movi(xy(2)-rAnn:xy(2)+rAnn,xy(1)-rAnn:xy(1)+rAnn,frame-fBack:frame-1));
    miniC = ...
double(movi(xy(2)-rAnn:xy(2)+rAnn,xy(1)-rAnn:xy(1)+rAnn,frame+j));
    miniAv = sum(miniM,3)./fBack;
    miniCb = miniC-miniAv; %Background subtracted current image
    miniAv = miniAv(:,:,ones(1,fBack));
    miniMb = miniM - miniAv; %Background subtracted background images (average 0
%Segmentation with intensity threshold
    miniStd = std(miniMb(:));
    evThr = miniStd*sigNoise/corrFactor; 
%a correction factor for segmentation, at 2 (see line 67)
%%%Filtering of movie, gaussian filter (default params)
    hgauss = fspecial('gaussian');
    %miniCf = miniCb;
    miniCf = imfilter(miniCb,hgauss); %Need to check if necessary
    sMini = miniCf>evThr; %segmented current image
    lMini = bwlabel(sMini,4); %labelling of 4-connected objects
    prop = regionprops(lMini,'Area','Centroid');
    if ~isempty(prop)
        nObj = size(prop,1); %Number of detected objects
        adObj = zeros(nObj,3); %Area and distance from center of image
        for lp = 1:nObj
            xyC = prop(lp).Centroid;
            adObj(lp,1) = sqrt((xyC(1)-rAnn-dxy(1)-1)^2+(xyC(2)-rAnn-dxy(2)-1)^2);
            adObj(lp,2) = prop(lp).Area > (pixThresh-1);
            adObj(lp,3) = lp;
        end
        adObj = sortrows(adObj,[-2 1]);
        if adObj(1,2) && adObj(1,1) < maxMvt
            xyC = prop(adObj(1,3)).Centroid;
            dxy(1) = xyC(1) - floor(xyC(1));
            dxy(2) = xyC(2) - floor(xyC(2));
            xy(1) = floor(xy(1)+xyC(1)-rAnn-1);
            xy(2) = floor(xy(2)+xyC(2)-rAnn-1);
            nLine = zeros(1,6);
            nLine(1) = i;
            nLine(2) = frame+j;
            nLine(3) = xy(1)+dxy(1)-sTRC;
            nLine(4) = xy(2)+dxy(2)-sTRC;
            nLine(5) = prop(adObj(1,3)).Area;
            nLine(6) = 0; %Could put circle-annulus data, or background subtracted...
            nEv = cat(1,nEv,nLine);
            %To calculate the slope
            if j == 2
                distance = sqrt((x-rAnn-dxy(1)-1).^2 + (y-rAnn-dxy(2)-1).^2);
                circle = distance<rCircle;
                annulus = (distance>=rCircle)&(distance<rAnn);
                nPix = squeeze(round(sum(sum(annulus))))';
                nLoPix = round(nPix*lowpercent);
                nHiPix = round(nPix*highpercent);   
                back2 = miniC.*annulus;
            sortback2 = sort(reshape(back2,miniPix,1));
            background2 = ...
sum(sortback2(miniPix-nPix+nLoPix+1:miniPix-nPix+nHiPix))./(nHiPix-nLoPix);
            val2 = sum(sum(miniC.*circle))/sum(sum(circle));
            fluo2 = val2 - background2;
            slope = 0.5*(fluo2/fluo(end)-1);
            end
            j = j + 1;
            %calculates if object next frame will be too close to an edge
            edge_xs = nLine(3) < Edge;
            edge_xl = nLine(3) > (size(movi,2)-Edge);
            edge_ys = nLine(4) < Edge;
            edge_yl = nLine(4) > (size(movi,1)-Edge);
            edge_xy = edge_xs|edge_xl|edge_ys|edge_yl;
            if edge_xy
                if j > 0
                    j = j-1;
                    nEv = nEv(1:end-1,:);
                    disp([num2str(events(i,1)),': stop edge!'])
                end
            end
        else
            isObj = 0;
        end
    else
        isObj = 0;
    end
end

                if j > minTrack-1 %minTrack must be greater than 3
                    if slope < slopeMax
                        if ~isempty(coeff) %condition if there is a red channel to quantify
                    edge_xsR = interPolx(nEv(:,3),nEv(:,4),coeff) < Edge;
                    edge_xlR = interPolx(nEv(:,3),nEv(:,4),coeff) > (size(movi,2)-Edge);
                    edge_ysR = interPoly(nEv(:,3),nEv(:,4),coeff) < Edge;
                    edge_ylR = interPoly(nEv(:,3),nEv(:,4),coeff) > (size(movi,1)-Edge);
                            edge_xyR = [edge_xs,edge_xl,edge_ys,edge_yl];
                            edgeR = sum(sum(edge_xyR));
                        else
                           edgeR = 0;
                        end
                        if edgeR == 0
                           nEvents = cat(1,nEvents,nEv);
                            a = a+1;
                            accept(a,1:4) = events(i,1:4);
                            accept(a,5) = j;
                            accept(a,6) = slope;
                            accept(a,7) = SN;
                            accept(a,8) = coClst;
                        else
%rejection: event is too close to an edge in the red channel
                            r = r+1;
                            reject(r,1:4) = events(i,1:4);
                            reject(r,5) = j;
                            reject(r,6) = slope;
                            reject(r,7) = SN;
                            reject(r,8) = coClst;
                            reject(r,9) = j<=minTrack;
                            reject(r,10) = slope>slopeMax;
                            reject(r,11) = (SN <= sigNoise);
                            reject(r,12) = (coClst <= thClst);
                            reject(r,13) = 1;
                        end
                    else
%rejection: slope is greater than slopeMax
                    r = r+1;
                    reject(r,1:4) = events(i,1:4);
                    reject(r,5) = j;
                    reject(r,6) = slope;
                    reject(r,7) = SN;
                    reject(r,8) = coClst;
                    reject(r,9) = j<=minTrack;
                    reject(r,10) = slope>slopeMax;
                    reject(r,11) = (SN <= sigNoise);
                    reject(r,12) = (coClst <= thClst);
                    end
                else
%rejection: object tracked for less than minTrack frames
                    r = r+1;
                    reject(r,1:4) = events(i,1:4);
                    reject(r,5) = j;
                    %reject(r,6) = slope;
                    reject(r,7) = SN;
                    reject(r,8) = coClst;
                    reject(r,9) = j<=minTrack;
                    %reject(r,10) = slope>slopeMax;
                    reject(r,11) = (SN <= sigNoise);
                    reject(r,12) = (coClst <= thClst);
                end
            else
%rejection: pre existing cluster too small
                r = r+1;
                reject(r,1:4) = events(i,1:4);
                reject(r,5) = 0;%Length of tracking, no track here
                %reject(r,6) = slope; No slope calculated
                reject(r,7) = SN;
                reject(r,8) = coClst;
                reject(r,11) = (SN <= sigNoise);
                reject(r,12) = (coClst <= thClst);
            end
        else
%rejection: S/N is too low
            r = r+1;
            reject(r,1:4) = events(i,1:4);
            reject(r,5) = 0;%Length of tracking, no track here
            %reject(r,6) = slope;
            reject(r,7) = SN;
            reject(r,8) = coClst;
            reject(r,11) = (SN <= sigNoise);
            reject(r,12) = (coClst <= thClst);
        end
    else
%rejection: event is too close to an edge
    r = r+1;
    reject(r,1:4) = events(i,1:4);
    reject(r,13) = 1;
    end
end

if a > 0
    accept = accept(1:a,:);
else
    errordlg('No event has passed the screen')
    return
end
if r > 0
    reject = reject(1:r,:);
else
    reject = [];
end

sumReject = sum(reject);
rejectRank = 100.*reject(:,10)+10.*reject(:,11)+reject(:,12);
reject = [reject,rejectRank];
counts = [(r+a);sumReject(9:13)';a];

cellHigh = max(size(accept,1),size(reject,1))+15;
tableSum = cell(cellHigh,23); %the cell array that will contain the xls sheet
tableSum(1:3,1) = {'exp type:';'analysis:';'date:'};
tableSum(1:2,2) = {'ppH';'cleanupDiff'};
tableSum{3,2} = date;
tableSum(5:9,1) = {'rCircle';'rAnnulus';'Edge';'S/N';'(+)slope'};
tableSum(10:13,1) = {'cluster';'fr_bef';'fr_aft';'max_Mvt'};
tableSum(5:13,2) = num2cell(params');
tableSum(4,6:7) = {'start MIA','Added'};
tableSum(5:8,4) = {'total events:';'failed frbef:';'failed fraft:';'failed edges:'};
tableSum(9:12,4) = {'failed slope:';'failed S/N:';'failed cluster:';'failed merge:'};
tableSum{13,4} = 'passed:';
tableSum(5:11,6) = num2cell(counts);
tableSum{14,1} = 'passed events';
tableSum{14,10} = 'failed events';
tableSum(15,1:8) = {'new id','fr','x','y','lifetime','slope','S/N','cluster'};
%new id is new assigned event number, old id is the one given by MIA
tableSum(15,10:17) = {'trk id','fr','x','y','lifetime','slope','S/N','cluster'};
tableSum(15,18:23) = {'track','(+)slope','S/N','cluster','edges','rRank'};
if ~isempty(accept)
    tableSum(16:15+size(accept,1),1:9) = num2cell(accept);
end
if ~isempty(reject)
    tableSum(16:15+size(reject,1),10:23) = num2cell(reject);
end

[fle,p] = uiputfile([cellNum,'_clnDiff',num2str(minFrame),'.trc']...
      ,'Where to put the cleaned up event file');
  
if ischar(fle) && ischar(p)
   dlmwrite([p,fle],nEvents,'\t')
end

[fexcel,p] = uiputfile([cellNum,' candidates(',num2str(minFrame),').xlsx'],...
    'Where to put the excel data file');

if ischar(fexcel)&&ischar(p)
    warning off MATLAB:xlswrite:AddSheet
    sheet = [cellNum,' summary'];
    xlswrite([p,fexcel],tableSum,sheet)
end

%making graphs of parameters with thresholds
iSN = find(reject(:,6));
if ~isempty(iSN) && ~isempty(accept)
    naccept = size(accept,1);
    slopeAccept = sort(accept(:,6));
    slopeGraph = sort(reject(iSN,6));
    SNAccept = sort(accept(:,7));
    SNGraph = sort(reject(iSN,7));
    clusterAccept = sort(accept(:,8));
    clusterGraph = sort(reject(iSN,8));
    totR = size(iSN,1);
    fractionR = 1/totR:1/totR:1;
    fractionA = 1/naccept:1/naccept:1;
    scr = get(0,'ScreenSize');
    figure('name',[cellNum,'Thresholds cleanup'],...
        'position',[scr(3)/4 scr(4)/2 scr(3)/2 scr(4)/4])
    
    subplot(1,3,1)
    plot(slopeGraph,fractionR,slopeAccept,fractionA,'r')
    line([slopeMax slopeMax],[0 1],'color','k')
    axis square
    axis([-1 1 0 1])
    title('slope')
    text(-2,1.1,[num2str(a),' candidates']) % Mo added the -1 because a is 
                                              % 1 candidate too high... why?
    
    subplot(1,3,2)
    plot(SNGraph,fractionR,SNAccept,fractionA,'r')
    line([sigNoise sigNoise],[0 1],'color','k')
    axis square
    axis([0 20 0 1])
    title('S/N')
    
    subplot(1,3,3)
    plot(clusterGraph,fractionR,clusterAccept,fractionA,'r')
    line([thClst thClst],[0 1],'color','k')
    axis square
    axis([0 1 0 1])
    title('cluster fraction')
    
    %c = strfind(f,'_');
    %if isempty(c)
    %    c = 5;
    %else c = c(1)-1;
    
    [fth, pth] = uiputfile([cellNum,'_thresholds',num2str(minFrame),'.fig'],'save figure');
    if ischar(fth) && ischar(pth)
        saveas(gcf,[pth,fth]);
    end 
end

%dlmwrite([p,cellNum,'nTrk.trc'],nEvents,'\t')

function u = interPolx(x,y,c)
u = c(1) + c(2).*x + c(3).*x.^2 + c(4).*x.^3 +...
   c(5).*y + c(6).*y.^2 + c(7).*y.^3;

function v = interPoly(x,y,c)
v = c(8) + c(9).*x + c(10).*x.^2 + c(11).*x.^3 +...
   c(12).*y + c(13).*y.^2 + c(14).*y.^3;

